<!DOCTYPE html>
<html><head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">

    <title>Keep (◍°∇°◍)ﾉﾞ | 操作系统基础-存储管理</title>
    <meta name="description" content="存储管理 1.存储和CPU之间的关系 缓存据有容量小、速度高的特点，而内存相比之下则容量大而速度低。 如下 ">
    <link rel="canonical" href="http://xxx.xxx/posts/os/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E5%AD%98%E5%82%A8%E7%AE%A1%E7%90%86/" />
    <link rel="icon" type="image/x-icon" href="/images/favicon.ico">
    <meta property="og:title" content="操作系统基础-存储管理" />
<meta property="og:description" content="存储管理 1.存储和CPU之间的关系 缓存据有容量小、速度高的特点，而内存相比之下则容量大而速度低。 如下" />
<meta property="og:type" content="article" />
<meta property="og:url" content="http://xxx.xxx/posts/os/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E5%AD%98%E5%82%A8%E7%AE%A1%E7%90%86/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-05-12T13:26:11+08:00" />
<meta property="article:modified_time" content="2022-05-12T13:26:11+08:00" />



    <meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="操作系统基础-存储管理"/>
<meta name="twitter:description" content="存储管理 1.存储和CPU之间的关系 缓存据有容量小、速度高的特点，而内存相比之下则容量大而速度低。 如下"/>

    
        
    
    <link rel="stylesheet" href='/css/style.css' />
    <link rel="stylesheet" href='/css/search.css' />
    <link rel="stylesheet" href='/css/md_nb.css' />
    <link rel="stylesheet" href='/css/list.css' />
    <link rel="stylesheet" href='/css/terms.css' />
    <link rel="stylesheet" href='/css/taxonomy.css' />
    <link rel="stylesheet" href='/css/home.css' />
    <link rel="stylesheet" href='/css/syntax.css' />
    
        <link rel="stylesheet" href='/css/comment.css' />
    
    <link rel="stylesheet" href='/css/shortcode.css' />
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css">
    
    <link rel="stylesheet" href='/css/_custom.css' />
    <style>
         
    </style>
    
    
        <script src='//cdnjs.cloudflare.com/ajax/libs/valine/1.5.0/Valine.min.js'></script>
    
    <script>
    MathJax = {
      tex: {
        inlineMath: [["\\(", "\\)"]],
      },
      displayMath: [
        ["$$", "$$"],
        ["\[\[", "\]\]"],
      ],
      svg: {
        fontCache: "global",
      },
    };
</script>
<script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
<script
  id="MathJax-script"
  async
  src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"
></script>


    <script src="https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.min.js"></script>
    <script src="/js/lazysizes.min.js" async=""></script>
    <script src="https://apps.bdimg.com/libs/jquery/2.1.4/jquery.min.js"></script>
    <script src="/js/search.js"></script>
    <script src="/js/md_nb.js"></script>
    
    <script src="/js/yes.js"></script>
    
    
        <script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    
</head><body style="font-family: ,'Helvetica Neue', Helvetica, Arial, 'PingFang SC', 'Hiragino Sans GB', 'Heiti SC', 'Microsoft YaHei', 'WenQuanYi Micro Hei', sans-serif;">
        <div class="loading">
            <div class="loading-bg"></div>
            <div class="loading-long">
                <div class="loading-short"></div>
            </div>
        </div>

        <header>
    <nav class="navbar">
        <div class="navbar-brand">
            <a href="/">
                <span class="logo">Keep (◍°∇°◍)ﾉﾞ</span>
            </a>
        </div>
        <div class="navbar-menu">
            
                <a href="/">
                    <div class="menu-item">
                        <div class="hengtiao-root">
                            <div class="hengtiao"></div>
                            <div class="name text-wbd-reverse"><i class='fa fa-home'></i> 首页</div>
                        </div>
                    </div>
                </a>
            
                <a href="/posts">
                    <div class="menu-item">
                        <div class="hengtiao-root">
                            <div class="hengtiao"></div>
                            <div class="name text-wbd-reverse"><i class='fa fa-book'></i> 文章</div>
                        </div>
                    </div>
                </a>
            
                <a href="/categories">
                    <div class="menu-item">
                        <div class="hengtiao-root">
                            <div class="hengtiao"></div>
                            <div class="name text-wbd-reverse"><i class='fa fa-folder-open'></i> 分类</div>
                        </div>
                    </div>
                </a>
            
                <a href="/tags">
                    <div class="menu-item">
                        <div class="hengtiao-root">
                            <div class="hengtiao"></div>
                            <div class="name text-wbd-reverse"><i class='fa fa-tags'></i> 标签</div>
                        </div>
                    </div>
                </a>
            
                <a href="/about">
                    <div class="menu-item">
                        <div class="hengtiao-root">
                            <div class="hengtiao"></div>
                            <div class="name text-wbd-reverse"><i class='fa fa-info-circle'></i> 关于</div>
                        </div>
                    </div>
                </a>
            
            <div class="navbar-burger">
                <div class="burger-btn"><span><i class="fa fa-navicon"></i></span></div>
            </div>
            
            
            <div class="search-in"><span><i class="fa fa-search"></i></span></div>
            
                <div class="mode">
                    <span class="sun"><i class="fa fa-sun-o"></i></span>
                    <span class="moon"><i class="fa fa-moon-o"></i></span>
                </div>
            
        </div>
    </nav>
    <div class="burger-items">
        
        <a href="/">
            <div class="burger-item">
                <i class='fa fa-home'></i> 首页
            </div>
        </a>
        
        <a href="/posts">
            <div class="burger-item">
                <i class='fa fa-book'></i> 文章
            </div>
        </a>
        
        <a href="/categories">
            <div class="burger-item">
                <i class='fa fa-folder-open'></i> 分类
            </div>
        </a>
        
        <a href="/tags">
            <div class="burger-item">
                <i class='fa fa-tags'></i> 标签
            </div>
        </a>
        
        <a href="/about">
            <div class="burger-item">
                <i class='fa fa-info-circle'></i> 关于
            </div>
        </a>
        
    </div>
    <div class="header-rest"></div>
</header>


        <div id="content">








    <div class="hero">
        
            <div class="hero-img">
                <img class="lazyload" src="/images/thumbnail.gif" data-src="/images/os/os.png" alt="">
            </div>
        
        <div class="hero-content">
            <div class="hero-title">操作系统基础-存储管理</div>
            <div class="hero-subtitle"></div>
            <div class="hero-date">
                    <span class="no-wrap"><i class="fa fa-calendar"></i> 发布于: 2022-5-12 &nbsp;</span>
                    <span class="no-wrap"><i class="fa fa-calendar-check-o"></i> 更新于: 2022-5-12 &nbsp;</span>
                    <span class="no-wrap"><i class="fa fa-folder"></i>
                        收录于:
                        
                            <a href='
                                /categories/os
                            '>
                                OS
                            </a>
                    </span>    
            </div>
            <div class="timelong">
                <span class="no-wrap"><i class="fa fa-pencil"></i> 文章字数: 3010 &nbsp;</span>
                <span class="no-wrap"><i class="fa fa-clock-o"></i> 阅读时间: 7 分钟 &nbsp;</span>
                <span class="no-wrap"><i class="fa fa-eye"></i> 阅读量: <span id="busuanzi_value_page_pv"></span></span>
            </div>
        </div>
    </div>




<div class="zhuti-0">
    <div class="container">
        <div class="zhuti">
            <div class="zhuti-l">
                




    


<div class="content-root">
    <div class="long">
        <button class="tosides-1 text-wbd">
            <i class="fa fa-arrow-right"></i>
        </button>
        <button class="tosides-2 text-wbd">
            <i class="fa fa-arrow-left"></i>
        </button>
        <button class="toup text-wbd">
            <i class="fa fa-arrow-up"></i>
        </button>
    </div>
    
        <div class="content">
            <div class="content-self">
                <h1 id="存储管理">存储管理</h1>
<h2 id="1存储和cpu之间的关系">1.存储和CPU之间的关系</h2>
<p>缓存据有容量小、速度高的特点，而内存相比之下则容量大而速度低。</p>
<p>如下图所示，由于<strong>CPU</strong>跟<strong>内存</strong>之间的速度悬殊，通常在<strong>CPU</strong>跟<strong>内存</strong>之间增加<strong>高速缓存</strong>来提高性能。<img src="/images/os/CPU-%E7%BC%93%E5%AD%98-%E5%86%85%E5%AD%98%E4%B9%8B%E9%97%B4%E7%9A%84%E5%85%B3%E7%B3%BB.jpg" alt=""></p>
<p>因为缓存的容量较小，必然会有内存内容的换进和换出。这就会遵循局部性原理，即<strong>时间局部性</strong>、<strong>空间局部性</strong></p>
<ul>
<li>时间局部性：某段时间内会重复使用的内容不换出</li>
<li>空间局部性：与使用中内容空间联系紧密的不换出</li>
</ul>
<p><strong>如何计算Cache的平均访问时间？</strong></p>
<p>假设：cache的命中率为98%，命中的访问速度为2ns，不命中的访问速度为5ns，则cache的平均访问时间 = 98% * 2 + 2% * 5ns</p>
<p>CPU如何通过缓存访问主存，请看下图：<img src="/images/os/Cache%E5%91%BD%E4%B8%AD.png" alt=""></p>
<p>其中<strong>地址映射变换</strong>解决了主存和Cache块号不一致，因为有可能主存与Cache采用不同的分区策略，同时也增加了Cache的灵活性，可记录主存所有块号的任何为内容。</p>
<p>Cache的映射方式主要有以下几种：</p>
<ol>
<li><strong>直接映射</strong>：直接映射主存的页到Cache页，不灵活，块(页)冲突率较高；</li>
<li><strong>全相连映像</strong>：主存中的页可以映射到任何Cache中的页，灵活性高，但无法从主存块号中直接获取Cache的块号，需要增加额外映射；</li>
<li><strong>组相连映像</strong>：主存分区、分组，组内使用直接映射，组间使用全相连映像。</li>
</ol>
<p><em><strong>使用：距离CPU较近的可使用直接或组相连映像，距离较远的可使用全相连映射</strong></em></p>
<p><strong>cache与主存的一致性</strong></p>
<ol>
<li><strong>写回策略</strong>：CPU对cache写命中时，只修改cache的内容不立即写入主存，只有当此行被换出时才写入主存。</li>
<li><strong>写直达策略</strong>：又称写全或写透策略，cache写命中时，同时修改主存</li>
<li><strong>标记策略</strong>：cache换进时有效标记为1，CPU对cache写命中时，只写入主存并将cache标志位置0；当要从cache读取数据，发现cache标志位为0则直接从主存读取</li>
</ol>
<p><strong>cache的替换算法</strong></p>
<ol>
<li><strong>随机算法</strong>：当cache满时，随机选择一块替换掉</li>
<li><strong>先进先出（FIFO）</strong>：按进入cache的先后顺序，先进的优先被替换</li>
<li><strong>近期最少使用（LRU）</strong>：优先替换近期最少使用的块</li>
<li><strong>最不经常使用（LFU）</strong>：优先替换最不经常使用的块</li>
</ol>
<h2 id="2地址重定位">2.地址重定位</h2>
<blockquote>
<p>是将程序中的虚拟地址(逻辑地址)变换成内存的真实地址(物理地址)的过程</p>
</blockquote>
<ul>
<li>逻辑地址：也称为相对地址，是内部和编程使用的、并不唯一</li>
<li>物理地址：也称为绝对地址，是加载到内存地址寄存器的地址，内存单元的真正地址</li>
</ul>
<p>地址重定位分为：<strong>静态重定位</strong> 和 <strong>动态重定位</strong></p>
<ul>
<li>静态重定位：<span style="color:blue">绝对地址 = 相对地址 + 程序存放的内存起始地址</span></li>
<li>动态重定位：<span style="color:blue">绝对地址 = 重定位寄存器的值（BR）+ 逻辑地址寄存器的值（VR）</span></li>
</ul>
<p>静态重定位和动态重定位的优缺点：</p>
<ul>
<li>
<p>静态重定位需要在程序运行前就确定程序的位置（地址的映射关系）且不能移动，程序本身也需要占用连续的内存空间；</p>
</li>
<li>
<p>动态重定位可以再程序需要执行是根据BR和VR的记录去调度，占用的内存空间可动态变化，相对比较灵活，但增加了寄存器的开销</p>
</li>
</ul>
<h2 id="3存储管理的分类">3.存储管理的分类</h2>
<blockquote>
<p>存储管理的主要目的是解决多个用户使用主存的问题</p>
</blockquote>
<p>常见的存储管理方式有以下几种：</p>
<ol>
<li>
<p><strong>分区存储管理</strong>：</p>
<p>把主存划分为若干区域，每个区域值分配给一个用户作业使用并限定只能在自己的区域中运行；基于分区方式的不同可划分为：<strong>固定分区</strong>、<strong>可变分区</strong>、<strong>可重定位分区</strong>
使用分区表、标定每个区的区号、大小、起始地址和是否分配标志。<img src="/images/os/%E5%9B%BA%E5%AE%9A%E5%88%86%E5%8C%BA.jpg" alt=""></p>
</li>
</ol>
<p><em><strong>由于分区大小固定，分配后剩余的空间很容易被浪费掉!
根据程序的大小，使用不同的算法重新分配到各个分区中</strong></em>
<img src="/images/os/%E5%8F%AF%E5%8F%98%E5%88%86%E5%8C%BA.jpg" alt=""></p>
<p><em><strong>依然有空间的浪费，但相比固定分区要好很多</strong></em></p>
<p>通过移动内存中作业的位置，然后把原来多个分散的空闲小分区拼接成一个大分区。此时若不对程序和数据的地址加以修改（变换），则程序必将无法执行。为此，在每次“紧凑”后，都必须对移动了的程序或数据进行重定位。** <img src="/images/os/%E9%87%8D%E5%AE%9A%E4%BD%8D%E5%88%86%E5%8C%BA.jpg" alt=""></p>
<p>但由于重定位会增加系统开销，必须选择合适的时机进行，通常有一下两种：</p>
<ol>
<li>
<p>分区回收时执行；</p>
</li>
<li>
<p>找不到足够大空间时执行：</p>
</li>
<li>
<p><strong>分页存储管理</strong></p>
<blockquote>
<p>为了解决分区存储管理中会产生的大量碎片，分页存储的思想被提出了。</p>
<p>计提思路是：<span style="color:red">把主存存储空间划分为大小一定的块（称为物理块、或页框），把要执行的作业也按照同样的尺寸划分，如此作业便可以零散的放于主存的不连续的页框中，但需要增加页表(页号和页框的映射关系)去寻址。</span></p>
</blockquote>
<p><img src="/images/os/%E5%88%86%E9%A1%B5%E5%AD%98%E5%82%A8%E7%AE%A1%E7%90%86.jpg" alt=""></p>
<p>如上图所示，作业的各个页面与页框的对应，就是通过页表来实现。
把作业的地址空间划分成若干个大小相等的区域，称这样的每个区为页面或者简称页。</p>
<p>相应地，也需将主存空间划分为若干个大小相等的物理块，并使块与页的大小相同，这样，在将用户程序装入内存时，刚好一块中放页。</p>
<p>页的大小通常在 512B～4KB范围。</p>
<p>简称页表，其中列出了作业的逻辑地址与其在主存中 的物理地址间的对应关系。</p>
<p>一个页表中包含若干个表目，表目中的最基本内容是该页对应的物理块号。
<strong>假设每个页和物理块的大小均为1024B，逻辑地址为2100(十进制)，计算其物理地址？</strong><img src="/images/os/%E9%A1%B5%E8%A1%A8.jpg" alt="">解：</p>
<ul>
<li>页号：页号 = 逻辑地址 / 页大小，即：2100 / 1024 = 2</li>
<li>物理块偏移量 = 页偏移量 = 逻辑地址 % 页大小，即：2100 % 1024 = 52</li>
<li>物理块地址 =  物理块号(根据页表和所得页号查找) * 页大小 + 物理块偏移量，即：8 * 1024 + 52 = 8244</li>
</ul>
</li>
<li>
<p><strong>分段存储管理</strong></p>
<blockquote>
<p>分段式存储管理的作业空间是以段为单位的，每个段将占据一个连续的存储区域，但各段之间不必连续。</p>
<p>这样，一个作业的各个分段在主存的情况用一个段表来记录，它指出了主存中各个分段的起始地址和长度。</p>
<p>相对于分页存储来说，分段可以根据程序的实际情况，将程序内联系比较紧密的部分划分到一个段内，保护程序内部的逻辑完整性。</p>
</blockquote>
<p><img src="/images/os/%E5%88%86%E6%AE%B5%E5%AD%98%E5%82%A8%E7%AE%A1%E7%90%86.jpg" alt=""> <span style="color:red">段表由<strong>段号</strong>、<strong>段长</strong>、<strong>段始址</strong>组成。其中段长起到了限长的作用，逻辑地址到物理地址的换算和分页类似</span></p>
</li>
<li>
<p>段页式存储管理</p>
<blockquote>
<p>段页式存储管理兼顾了段式在逻辑上的清晰和页式在管理上方便的特点。</p>
<p>每一个装入内存的作业建立一张段表（基于作业），对每一段建立一张页表（系统决定页大小）</p>
</blockquote>
<p><img src="/images/os/%E6%AE%B5%E9%A1%B5%E5%BC%8F%E5%AD%98%E5%82%A8%E7%AE%A1%E7%90%86.jpg" alt=""></p>
<p><strong>逻辑地址到物理地址的计算：</strong></p>
<ul>
<li>访问段表获取段表始址</li>
<li>根据段表始址计算段表分页的页号，从而得到页表始址</li>
<li>根据得到的页表地址得到具体的物理</li>
</ul>
</li>
</ol>
<h2 id="4磁盘存储器">4.磁盘存储器</h2>
<blockquote>
<p>磁盘存储器一般由组合臂、主轴、读写头、盘面组成，盘面又分磁道，磁道分有扇区，扇区用来存储数据。所以磁盘存储器的<strong>存储容量 = 磁盘面数 x 每面的磁道数 x 每道扇区 x 每个扇区存储字节数</strong>，硬盘的存取时间 = 寻道时间 + 等待时间 +读/写时间。</p>
</blockquote>
<p>为了加深对硬盘存取时间理解，看下面一道例题：</p>
<p>在磁盘上存储数据的排列方式会影响 I/O 服务的总时间。假设每磁道划 分成 10 个物理块，每块存放 1 个逻辑记录。逻辑记录 RI.R2， &hellip;， RI0存放在同一个磁道上， 记录的安排顺序如下表所示;<img src="/images/os/%E7%A3%81%E7%9B%98%E5%AD%98%E5%82%A8%E9%A2%98-1.jpg" alt=""></p>
<p>假定磁盘的旋转速度为 30ms/周，磁头当前处在 R1 的开始处。若系统顺 序处理这些记录，使用单缓冲区，每个记录处理时间为 6ms，则处理这 10 个记录的<strong>最长时间</strong>为 （） ;若对信息<strong>存储进行优化分布</strong>后，处理 10 个 记录的<strong>最少时间</strong>为（）</p>
<p><span style="color:red"><strong>解</strong>：</span></p>
<ol>
<li>
<p><img src="/images/os/%E7%A3%81%E7%9B%98%E5%AD%98%E5%82%A8%E9%A2%98-2.png" alt=":inline">磁头初始位置如图所示，读取一条指令的时间 = 30ms / 10 = 3ms，处理一条指令耗时6ms，在处理完R1后，磁头位置如图所示(R1处理完)，此时耗时3ms(读) + 6ms(执行) = 9ms；</p>
<p>如果开始处理R2，磁头需要从当前位置（R1处理完）空转到R2执行开始处，耗时8 x 3ms = 24ms，因此处理完R1并回到R2的开始位置总耗时 24ms + 9ms = 33ms；</p>
<p>从R1&hellip;R9的耗时 = 33ms x 9 = 297ms，R10读取和执行也需要9ms，因此总耗时 = 297ms + 9ms = 306ms</p>
</li>
<li>
<p><img src="/images/os/%E7%A3%81%E7%9B%98%E5%AD%98%E5%82%A8%E9%A2%98-3.png" alt=":inline">假设从新排了顺序使得每次处理完磁头所在位置刚好是下一个要执行的指令，由第一问可知，一条指令完整的执行时间为9ms，10条则为90ms</p>
</li>
</ol>

            </div>
            
                <div class="tags">
                    
                    <span class="down-type-item">
                        <div class="type-text">
                            <a href='
                                        /tags/os
                                    '>
                                <i class="fa fa-tag"></i> OS
                            </a>
                        </div>
                    </span>
                    
                    <span class="down-type-item">
                        <div class="type-text">
                            <a href='
                                        /tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F
                                    '>
                                <i class="fa fa-tag"></i> 操作系统
                            </a>
                        </div>
                    </span>
                    
                </div>
            
        </div>
        
            
                <div class="pre-next">
                    
    
        
        <a href="http://xxx.xxx/posts/os/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80-%E8%BF%9B%E7%A8%8B/" class="pre">
            <span class="pre-icon"><i class="fa fa-hand-o-left"></i></span>
            <div class="pre-title-root">
                <span>操作系统基础-进程</span>
            </div>
        </a>
        

        
        <a href="http://xxx.xxx/posts/os/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80-pv%E6%93%8D%E4%BD%9C/" class="next">
            <div class="next-title-root">
                <span>操作系统基础-PV操作</span>
            </div>
            <span class="next-icon"><i class="fa fa-hand-o-right"></i></span>
        </a>
        

    
    

                </div>
            
        
    
</div>

    
        <div class="content-last">
            
                <button class="aixin content-last-item efct-button">
                    <i class="fa fa-heart"></i>
                </button>
            
            
                <button class="pinglun content-last-item efct-button">
                    <i class="fa fa-comment"></i>
                </button>
            
        </div>
    


            </div>
            <div class="zhuti-r">
                
<div class="zhuti-r-0">
    <div class="zhuti-r-1">
        
            <div class="button-r">
                <button class="button-mulu efct-button" type="button"><span><i class="fa fa-bars"></i></span><span class="bars-text"> 目录</span></button>
                <button class="button-comment efct-button" type="button"><span><i class="fa fa-comment"></i></span><span class="comment-text"> 评论</span></button>
            </div>
        
        <div id="r1">
            

<div class="about-zuozhe">
    <div class="zuozhe">
        
            <div class="datou">
                <img class="lazyload" src="/images/thumbnail.gif" data-src="/images/author.jpeg" alt="">
            </div>
        
        <div class="name-jianjie">
            <div class="name">Damon</div>
            <div class="jianjie">
                Be Water, My Friend.
            </div>
        </div>
    </div>

    <div class="type">
        <a href='
                    /posts/
                '>
            <p>文章</p>
            <p>12</p>
        </a>
        <a href='
                    /categories/
                '>
            <p>分类</p>
            <p>7</p>
        </a>
        <a href='
                    /tags/
                '>
            <p>标签</p>
            <p>13</p>
        </a>
    </div>

    <a href="https://github.com/LuckyCandy">
        <div class="follow">Follow Me</div>
    </a>
</div>
            <div class="mulu">
    <div class="dong"></div>
    <div class="zhi">
        <div class="wenzi">
            <div class="zhi-mulu text-wbd">目录</div>
            <div class="mulu-items">
            </div>
        </div>
    </div>
</div>
            



    
    


<div class="other">
    <div class="other-up">
        <div class="other-qita text-wbd">相关文章</div>
        <div class="xian"></div>
    </div>
    <div class="list">
        
            <a href="http://xxx.xxx/posts/os/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80-pv%E6%93%8D%E4%BD%9C/">
                
<a href="http://xxx.xxx/posts/os/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80-pv%E6%93%8D%E4%BD%9C/">
    <div class="list-item">
        <div class="icon-other-root">
            
                <div class="icon-other" style="background-image: url( /images/os/pv.jpg );"></div>
            
        </div>
        <div class="list-right">
            <div class="other-title">
                操作系统基础-PV操作
            </div>
            <div class="other-summary">PV操作 一种实现进程互斥与同步的有效方法，P表示加锁的意思，V表示释放的意思。 互斥信号量 如下图所示，</div>
            <div class="other-date">2022-5-13</div>
        </div>
    </div>
</a>
            </a>
        
            <a href="http://xxx.xxx/posts/os/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80-%E8%BF%9B%E7%A8%8B/">
                
<a href="http://xxx.xxx/posts/os/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80-%E8%BF%9B%E7%A8%8B/">
    <div class="list-item">
        <div class="icon-other-root">
            
                <div class="icon-other" style="background-image: url( /images/os/process.png );"></div>
            
        </div>
        <div class="list-right">
            <div class="other-title">
                操作系统基础-进程
            </div>
            <div class="other-summary">进程 操作系统：系统进行资源分配和调度的基本单位，也是最小单位。 用户角度：程序一次动态执行过程 组成 进程</div>
            <div class="other-date">2022-5-12</div>
        </div>
    </div>
</a>
            </a>
        
            <a href="http://xxx.xxx/posts/computer/checkcode/">
                
<a href="http://xxx.xxx/posts/computer/checkcode/">
    <div class="list-item">
        <div class="icon-other-root">
            
                <div class="icon-other" style="background-image: url( /images/computer/jym.png );"></div>
            
        </div>
        <div class="list-right">
            <div class="other-title">
                校验码
            </div>
            <div class="other-summary">校验码 信息保存在电容中，如果遇到电磁环境干扰，会导致电容的充放电或触发器的翻转，那么存在存储器的信息</div>
            <div class="other-date">2022-6-1</div>
        </div>
    </div>
</a>
            </a>
        
            <a href="http://xxx.xxx/posts/k8s/k8s.yaml/">
                
<a href="http://xxx.xxx/posts/k8s/k8s.yaml/">
    <div class="list-item">
        <div class="icon-other-root">
            
                <div class="icon-other" style="background-image: url( /images/k8s/k8s.png );"></div>
            
        </div>
        <div class="list-right">
            <div class="other-title">
                K8S-yaml配置解释
            </div>
            <div class="other-summary">yaml配置解释</div>
            <div class="other-date">2022-5-27</div>
        </div>
    </div>
</a>
            </a>
        
            <a href="http://xxx.xxx/posts/k8s/k8s.architecture/">
                
<a href="http://xxx.xxx/posts/k8s/k8s.architecture/">
    <div class="list-item">
        <div class="icon-other-root">
            
                <div class="icon-other" style="background-image: url( /images/k8s/k8s.png );"></div>
            
        </div>
        <div class="list-right">
            <div class="other-title">
                K8S-架构设计
            </div>
            <div class="other-summary">架构设计</div>
            <div class="other-date">2022-5-25</div>
        </div>
    </div>
</a>
            </a>
        
    </div>
</div>
        </div>
        <div id="r2">
            <div id="vcomments"></div>
<script src='//unpkg.com/valine/dist/Valine.min.js'></script>
<script type="text/javascript">
    new Valine({
        el: '#vcomments',
        appId: "kHsfZiFkt9k6HZdfXErim65a-gzGzoHsz",
        appKey: "ehZsksz6JlCVUSBolnxqMmBj",
        avatar: "robohash",
        placeholder: "输入你的评论",
        requiredFields: ["nick"],
        visitor:  true ,
        pageSize:  5 ,
});
</script>

        </div> 
    </div>
</div>

            </div>
        </div>
    </div>
</div>

    

<div class="sponsor">
    <div class="sponsor-self">
        <div class="sponsor-title">赞赏</div>
        <div class="sponsor-btn">
            
                
                    
                        <div class="sponsor-btn-1 border-r">Wechat</div>
                    
                
                
            
                
                    
                        <div class="sponsor-btn-2 border-l">Alipay</div>
                    
                
                
            
        </div>
        
        <div class="sponsor-img">
            
                
                    <img class="sponsor-img-1" src="/images/sponsor/wechat.jpeg" alt="">
                
                
            
                
                    <img class="sponsor-img-2" src="/images/sponsor/alipay.jpeg" alt="" style="display: none;">
                
                
            
        </div>
        <div class="cancel efct-button">取消</div>
    </div>
</div>


        </div>

        <footer class="footer">
    
        <div class="container">
            <div class="footer-items">
                
                    <div class="footer-item">
                        <i class="fa fa-user"></i> <span id="busuanzi_value_site_pv"></span> |
                        <i class="fa fa-eye"></i> <span id="busuanzi_value_site_uv"></span>
                    </div>
                
                
                    <div class="footer-item">
                        © 2023-2023 <a href="https://github.com/LuckyCandy">Damon</a>
                    </div>
                
                
                    <div class="footer-item">
                        Powered by <a href="https://gohugo.io/">Hugo</a>
                    </div>
                
            </div>
        </div>
    

    
</footer>


        
        <div class="search-root">
    <div class="search-zz"></div>
    <div class="search">
        <div class="sheader anniu">
            <div class="sh-l">
                <input type="text" placeholder='请输入关键词' id="search-key">
                <span class="sclear"><i class="fa fa-close"></i></span>
            </div>
            <div class="sh-r">
                <button>搜索</button>
            </div>
        </div>
        <div class="sbody">
            <div class="sbody-1">
                <div class="stip"></div>
            </div>
        </div>
    </div>
</div>
        








    
    

    
    

    
    

    
    

    
    

    
    

    
    

    
    

    
    

    
    

    
    

    
    


<script type="text/javascript">
    var mode_custom = "auto";
    var postsCount =  12 ;
    var arrPosts = [{"link":"http://xxx.xxx/posts/sys/manual/","plain":"Blog的搭建说明 1. 运行项目 安装Hugo 安装Git 克隆项目到本地\n1 git clone git@github.com:LuckyCandy/blog.git 运行项目\n1 2 3 4 5 cd blog # 使用主题默认配置 cp themes/NewBee/cnofig-example/config.toml cnofig.toml # 启动服务 hugo server -D 2.发布新内容 创建新文章\n1 hugo new posts/你的文章.md 前置参数解释\n你可以在文章前面添加.toml、.yaml或者.json格式的前置参数。\n属性 解释 title 文章标题 subtitle 文章副标题 date 这篇文章创建的日期 lastmod 最近修改内容的日期 draft 在生成静态页面时记得改为true，否则除非使用了hugo -D或者hugo \u0026ndash;buildDrafts命令, 否则这篇文章将不会被渲染。 description 文章内容描述 summary 文章摘要 image 文章页首图片，没有则使用默认 tags 文章标签 categories 文章所属类别 series 文章所属系列 3.语法\n全面支持Markdown，语法的详细说明参考官方文档 更加丰富的功能，参考【Shortcodes】(https://hugoloveit.com/zh-cn/theme-documentation-extended-shortcodes/) 3.编译静态页，发布到Github 编译静态资源 1 2 3 4 5 6 7 8 # 此时前置参数daft：true的将不会编译 cd blog \u0026amp; hugo # 执行完上一步会在public文件下生成所有的静态资源 cd public # 将这个目录的所有文件推送到Github public % git add . public % git commit -m \u0026#34;first commit\u0026#34; public % git push ","pubDate":"2023-02-23","title":"使用手册"},{"link":"http://xxx.xxx/posts/computer/checkcode/","plain":"校验码 信息保存在电容中，如果遇到电磁环境干扰，会导致电容的充放电或触发器的翻转，那么存在存储器的信息就可能会出错，因此必须存在相应的技术去校验信息是否准确，校验码的概念被提出。常见的校验方法有：奇偶校验码、海明码、循环冗余校验码。\n什么是码距？ 要给字母A，B编码，使用一位长度的二进制来编码，即：A = 0，B = 1 或者 A = 1，B = 0，此时因为只有一位长度，码距只能是1 如果使用二位长度的二进制来编码， 可选编码则有00,01,10,11四种 如果使用 A = 00， B = 01 或 A = 10，B = 11 来编码，存储的字符(AB)的编码即为{00,01}或{10,11}。此时如果遇到干扰，字符B由01变为了00，而00又是A的合法编码，就无法验证是否存储的内容发生过变化了 如果使用 A = 00，B = 11 或 A = 10，B = 01 来编码，存储的字符(AB)的编码即为{00,11}或{10,01}。此时如果遇到干扰，任何一个字符变化都会被标识为非法(两位都变化的则不能监测) 根据上面的分析，明显2的设计要优于1，不难发现采用2的编码方式，两位长度的二进制都不一样，所以我们可以说此时的码距为2，第一种方案只有一位不同，码距则为1。所以，码距就是任意两个二进制编码之间不同bit（位）的最小个数。 如何设置合适码距？ 正如上面的（2）如果两位都发生变化00变为了11，而11也是合法编码，无法判定是否发生错误。此时码距(d)为2，可以检测误码位数(e)为1，故此：在一个码组内要检测e个误码，则最小码距应该满足 d ≥ e + 1\n码距设为2时，可以检测一位误码，但是却无法进行修正。比如错误码 01，无法确定是00还是11发生一位变换而来，因此：在一个码组内要纠正t个误码，要求最小的码距应该满足 d ≥ 2t + 1\n如要同时具备纠错检错能力，则码距需要满足：d ≥ e + t + 1\n奇偶校验码 在原始码基础上增加一位校验位，校验位可以是0或者1，使其含有奇(偶)数个1\n拿偶校验举例：假设原始码为11000011，增加一位校验位，由于采用偶校验，原始码中1的个数已经是偶数个，所以校验码补0，即011000011 假如传输是发生一位错误，变为011000010，1的个数变为奇数个，成功检测出错误 假如传输是发生二位错误，变为011000000，1的个数变还是偶数个，无法检测出错误 因此，无论是奇校验还是偶校验，只能检测出奇数个位出错的情况\n海明码 原始码长度为m，在原始码的2^n(n ≥ 0)位置增加k个校验位，数据长度增长为m + k。将原始码分组，每组分配一个校验码，则工可以表示2^k个状态，其中1个表示所有组均没有错，2^k - 1个表示某些组出错情况；当满足2^k - 1 ≥ m + k时，就可以判断出具体是哪一位出错。\n假设要传输的原始码为：1010，求使用奇校验的海明校验码之后的传输内容？\n根据公式 2^k - 1 ≥ m +k，此时m = 4，可得最小k = 3，由于校验位在2^n位置，则原始码可写为：\n每组一个校验码，k=3则需要分为3组：\n第一组序号第一位(从右向左)为1的：3（011）, 5（101）, 7（111），即0100 第二组序号第二位(从右向左)为1的：3（011）, 6（110）, 7（111），即1110 第三组序号第三位(从右向左)为1的：5（101）, 6（110）, 7（111），即0010 于是可得，k1 = 0，k2 = 1，k3 = 0，带入上图位置，传输内容为：0110010\n接受结果为0110110是否正确？如果错误请指出具体的错误处。\n由（1）可知，接受结果错误，即数据在传输过程中发生了变化\n按照（1）中的分组进行校验：\n一组：校验码为序号为1(2^0)，即0，序号「3,5,7」一组，则此组内容为0110，非奇数个1，校验结果为1(错误) 二组：校验码为序号为2(2^1)，即1，序号「3,6,7」一组，则此组内容为1110，奇数个1，校验结果为0(正确) 三组：校验码为序号为4(2^2)，即0，序号「5,6,7」一组，则此组内容为0110，非奇数个1，校验结果为1(错误) 校验所得错误码为101（第一组校验结果|第二组校验结果|第三组校验结果），即序号5的内容发生了改变\nCRC循环冗余校验码 数据传输双方约定一个除数，被除数为原始信息 + R个校验位，需要保证被除数 模二除 除数，余数为0，如果非0则认为数据传输过程中出现错误。被除数通常已多项式方式表示，例如：G(x)=x^3 + x^2 + 1对用的二进制码为1101\n要传输的原始数据为101001，双方约定的除数(多项式)为G(x)=x^3 + x^2 + 1，求CRC码\n有多项式可知，除数的二进制表示为1101 多项式最大次幂为3，则校验位有3位，原始数据需要补0左移3位，即101001000 进行模2除法(不进位加法)计算： 所求CRC码为：101001001，验证即可使用101001001 模二除 1101，余数为0则验证成功。\n","pubDate":"2022-06-01","title":"校验码"},{"link":"http://xxx.xxx/posts/k8s/k8s.yaml/","plain":"K8S-yaml配置解释 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 apiVersion: v1 #必选，版本号，例如v1 kind: Pod #必选，Pod metadata: #必选，元数据 name: string #必选，Pod名称 namespace: string #必选，Pod所属的命名空间 labels: #自定义标签 - name: string #自定义标签名字 annotations: #自定义注释列表 - name: string spec: #必选，Pod中容器的详细定义 containers: #必选，Pod中容器列表 - name: string #必选，容器名称 image: string #必选，容器的镜像名称 imagePullPolicy: [Always | Never | IfNotPresent] #获取镜像的策略 Alawys表示下载镜像 IfnotPresent表示优先使用本地镜像，否则下载镜像，Nerver表示仅使用本地镜像 command: [string] #容器的启动命令列表，如不指定，使用打包时使用的启动命令 args: [string] #容器的启动命令参数列表 workingDir: string #容器的工作目录 volumeMounts: #挂载到容器内部的存储卷配置 - name: string #引用pod定义的共享存储卷的名称，需用volumes[]部分定义的的卷名 mountPath: string #存储卷在容器内mount的绝对路径，应少于512字符 readOnly: boolean #是否为只读模式 ports: #需要暴露的端口库号列表 - name: string #端口号名称 containerPort: int #容器需要监听的端口号 hostPort: int #容器所在主机需要监听的端口号，默认与Container相同 protocol: string #端口协议，支持TCP和UDP，默认TCP env: #容器运行前需设置的环境变量列表 - name: string #环境变量名称 value: string #环境变量的值 resources: #资源限制和请求的设置 limits: #资源限制的设置 cpu: string #Cpu的限制，单位为core数，将用于docker run --cpu-shares参数 memory: string #内存限制，单位可以为Mib/Gib，将用于docker run --memory参数 requests: #资源请求的设置 cpu: string #Cpu请求，容器启动的初始可用数量 memory: string #内存清楚，容器启动的初始可用数量 livenessProbe: #对Pod内个容器健康检查的设置，当探测无响应几次后将自动重启该容器，检查方法有exec、httpGet和tcpSocket，对一个容器只需设置其中一种方法即可 exec: #对Pod容器内检查方式设置为exec方式 command: [string] #exec方式需要制定的命令或脚本 httpGet: #对Pod内个容器健康检查方法设置为HttpGet，需要制定Path、port path: string port: number host: string scheme: string HttpHeaders: - name: string value: string tcpSocket: #对Pod内个容器健康检查方式设置为tcpSocket方式 port: number initialDelaySeconds: 0 #容器启动完成后首次探测的时间，单位为秒 timeoutSeconds: 0 #对容器健康检查探测等待响应的超时时间，单位秒，默认1秒 periodSeconds: 0 #对容器监控检查的定期探测时间设置，单位秒，默认10秒一次 successThreshold: 0 failureThreshold: 0 securityContext: privileged:false restartPolicy: [Always | Never | OnFailure]#Pod的重启策略，Always表示一旦不管以何种方式终止运行，kubelet都将重启，OnFailure表示只有Pod以非0退出码退出才重启，Nerver表示不再重启该Pod nodeSelector: obeject #设置NodeSelector表示将该Pod调度到包含这个label的node上，以key：value的格式指定 imagePullSecrets: #Pull镜像时使用的secret名称，以key：secretkey格式指定 - name: string hostNetwork:false #是否使用主机网络模式，默认为false，如果设置为true，表示使用宿主机网络 volumes: #在该pod上定义共享存储卷列表 - name: string #共享存储卷名称 （volumes类型有很多种） emptyDir: {} #类型为emtyDir的存储卷，与Pod同生命周期的一个临时目录。为空值 hostPath: string #类型为hostPath的存储卷，表示挂载Pod所在宿主机的目录 path: string #Pod所在宿主机的目录，将被用于同期中mount的目录 secret: #类型为secret的存储卷，挂载集群与定义的secre对象到容器内部 scretname: string items: - key: string path: string configMap: #类型为configMap的存储卷，挂载预定义的configMap对象到容器内部 name: string items: - key: string path: string ","pubDate":"2022-05-27","title":"K8S-yaml配置解释"},{"link":"http://xxx.xxx/posts/k8s/k8s.architecture/","plain":"K8S架构设计 简介 Kubernetes最初源于谷歌内部的Borg，提供了面向应用的容器集群部署和管理。\nKubernetes 的目标旨在消除编排物理/虚拟计算，网络和存储基础设施的负担，并使应用程序运营商和开发人员完全将重点放在以容器为中心的原语上进行自助运营。\nKubernetes 具备完善的集群管理能力，包括多层次的安全防护和准入机制、多租户应用支撑能力、透明的服务注册和服务发现机制、内建负载均衡器、故障发现和自我修复能力、服务滚动升级和在线扩容、可扩展的资源自动调度机制、多粒度的资源配额管理能力。\n架构设计 核心组件：\nAPI Server：所有服务访问统一入口。对外暴露K8S的api接口，是外界进行资源操作的唯一入口，并提供认证、授权、访问控制、API注册和发现等机制。 Controller Manager：负责资源的调度，按照预定的调度策略将Pod调度到相应的机器上。比如Pod调度：监视新创建的 Pod，如果没有分配节点，就选择一个节点供他们运行 ETCD：分布式键值存储服务，能够为整个分布式集群存储一些关键数据，协助分布式集群运转。支持持久化，宕机可恢复。 Kubelet：直接跟容器引擎(比如DockerEngine)交互实现容器的生命周期管理。 Kube-Proxy：提供统一访问接口、提供有4层负载均衡、服务发现等功能 推荐组件：\nKube-dns：为集群提供DNS服务 Ingress Controller：为服务提供外网入口 Heapster：提供资源监控 Dashboard：GUI管理 Fluentd-elasticsearch：日志采集、存储与查询（docker原生支持Fluentd，故不使用logstash） ","pubDate":"2022-05-25","title":"K8S-架构设计"},{"link":"http://xxx.xxx/posts/computer/constructor-instructor/","plain":"计算机基础 1.计算机组成 控制器： 指挥程序运行 运算器： 进行算术运算、逻辑运算 存储器： 存放程序和数据 输入设备：将信息转换成计算机能识别的设备 输出设备：将计算机的处理结果转变成人们熟悉的形式 经过改进，将运算器和控制器合并统称为中央处理器，也就是我们常说的CPU，同时重心转移到以存储器为中心改进后的组成如下图所示：\n指令 我们的程序代码首先要经过编译（Compile），编译成汇编代码（ASM），汇编代码在经过汇编器（Assembler）翻译成机器码（Machine Code）。机器码就是一条一条的计算机指令。宏观上可以分为两部分，即操作码和数据地址。操作码用来标识一条指令的功能，数据地址则是该指令要操作的对象。 PC：指令（程序）计数器，总是指向下一条要执行的指令的地址； IR：指令寄存器，存放即将要执行的指令； ID：指令译码器，解读指令要执行的何种操作； MAR：地址寄存器，存放指令在内存中的地址，它的存在一定程度上解决了直接到内存查找速度上的不匹配； MDR：数据寄存器，存放从内存取出的数据/指令 PSW：状态寄存器，状态切换时，用于保存当前程序的执行状态 ALU：算术逻辑单元，进行算术、逻辑运算 ACC：累加寄存器，存放运算前的操作数，或运算结果的寄存器 执行步骤：5 + 3 取指：PC \u0026mdash;\u0026gt; MAR \u0026mdash;\u0026gt; M(存储器) \u0026mdash;\u0026gt;MDR \u0026mdash;\u0026gt; IR 分析：ID \u0026mdash;\u0026gt; CU \u0026mdash;\u0026gt; ACC(5) 执行：Ad \u0026mdash;\u0026gt; MAR \u0026mdash;\u0026gt; M \u0026mdash;\u0026gt; MDR \u0026mdash;\u0026gt; ACC 因此，指令周期 = 取指周期 + 分析周期 + 执行周期\n指令流水技术： 指令执行周期中，不同时期使用到的机器部件不同，A指令在执行时，可同步开启B指令的取指，如下图所示：\n流水线周期：指令周期中执行时间最长的一段（例如：取指时间=1，分析时间=3，执行时间=2，流水线周期 = 3） 流水线建立时间：第一条指令的执行时间 流水线吞吐率：指令条数 / 流水线执行时间 流水线最大吞吐率： 流水线加速比：不使用流水线的执行时间 / 使用流水线的执行时间 流水线指令执行需要的时间计算：\n理论公式：流水线建立时间 + （n - 1） * ∆t\n实践公式：（流水线分段数 + 流水线数 - 1）* ∆t\n举例如下：\n若流水线把一条指令分为取指、分析和执行三个部分，三部分的时间分别是取指2ns，分析2ns，执行1ns。\n那么流水线周期是多少？\n100条指令全部执行完毕需要的时间是多少，吞吐率、加速比个是多少？\n解：\n\u0026lt;1\u0026gt; 流水线周期 = 指令周期中执行时间最长的一段，即2ns\n\u0026lt;2\u0026gt; 按照理论公式：(2 + 2 + 1) + (100 - 1) * 2 = 203ns；按实践公式：（3 + 100 - 1）* 2 = 204ns\n\u0026lt;3\u0026gt; 吞吐率 = 100 / 203 ≈ 0.5, 加速比 = （2 + 2 + 1）* 100 / 203 ≈ 2.46\n","pubDate":"2022-05-20","title":"计算机基础"},{"link":"http://xxx.xxx/posts/os/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80-pv%E6%93%8D%E4%BD%9C/","plain":"PV操作 一种实现进程互斥与同步的有效方法，P表示加锁的意思，V表示释放的意思。\n互斥信号量 如下图所示，P1 ~ P4代表4个进程，S1 ~ S5是5个信号量。信号量的标注遵循一下原则：从小到大、从左到右，以及进程的执行顺序\n那么使用PV操作进行控制P1 ~ P4并发执行过程如下：\nP1执行：V(S1)、V(S2) P3执行：P(S2)、V(S3)、V(S5) P2执行：P(S1)、P(S3)、V(S4) P4执行：P(S4)、P(S5) ","pubDate":"2022-05-13","title":"操作系统基础-PV操作"},{"link":"http://xxx.xxx/posts/os/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E5%AD%98%E5%82%A8%E7%AE%A1%E7%90%86/","plain":"存储管理 1.存储和CPU之间的关系 缓存据有容量小、速度高的特点，而内存相比之下则容量大而速度低。\n如下图所示，由于CPU跟内存之间的速度悬殊，通常在CPU跟内存之间增加高速缓存来提高性能。\n因为缓存的容量较小，必然会有内存内容的换进和换出。这就会遵循局部性原理，即时间局部性、空间局部性\n时间局部性：某段时间内会重复使用的内容不换出 空间局部性：与使用中内容空间联系紧密的不换出 如何计算Cache的平均访问时间？\n假设：cache的命中率为98%，命中的访问速度为2ns，不命中的访问速度为5ns，则cache的平均访问时间 = 98% * 2 + 2% * 5ns\nCPU如何通过缓存访问主存，请看下图：\n其中地址映射变换解决了主存和Cache块号不一致，因为有可能主存与Cache采用不同的分区策略，同时也增加了Cache的灵活性，可记录主存所有块号的任何为内容。\nCache的映射方式主要有以下几种：\n直接映射：直接映射主存的页到Cache页，不灵活，块(页)冲突率较高； 全相连映像：主存中的页可以映射到任何Cache中的页，灵活性高，但无法从主存块号中直接获取Cache的块号，需要增加额外映射； 组相连映像：主存分区、分组，组内使用直接映射，组间使用全相连映像。 使用：距离CPU较近的可使用直接或组相连映像，距离较远的可使用全相连映射\ncache与主存的一致性\n写回策略：CPU对cache写命中时，只修改cache的内容不立即写入主存，只有当此行被换出时才写入主存。 写直达策略：又称写全或写透策略，cache写命中时，同时修改主存 标记策略：cache换进时有效标记为1，CPU对cache写命中时，只写入主存并将cache标志位置0；当要从cache读取数据，发现cache标志位为0则直接从主存读取 cache的替换算法\n随机算法：当cache满时，随机选择一块替换掉 先进先出（FIFO）：按进入cache的先后顺序，先进的优先被替换 近期最少使用（LRU）：优先替换近期最少使用的块 最不经常使用（LFU）：优先替换最不经常使用的块 2.地址重定位 是将程序中的虚拟地址(逻辑地址)变换成内存的真实地址(物理地址)的过程\n逻辑地址：也称为相对地址，是内部和编程使用的、并不唯一 物理地址：也称为绝对地址，是加载到内存地址寄存器的地址，内存单元的真正地址 地址重定位分为：静态重定位 和 动态重定位\n静态重定位：绝对地址 = 相对地址 + 程序存放的内存起始地址 动态重定位：绝对地址 = 重定位寄存器的值（BR）+ 逻辑地址寄存器的值（VR） 静态重定位和动态重定位的优缺点：\n静态重定位需要在程序运行前就确定程序的位置（地址的映射关系）且不能移动，程序本身也需要占用连续的内存空间；\n动态重定位可以再程序需要执行是根据BR和VR的记录去调度，占用的内存空间可动态变化，相对比较灵活，但增加了寄存器的开销\n3.存储管理的分类 存储管理的主要目的是解决多个用户使用主存的问题\n常见的存储管理方式有以下几种：\n分区存储管理：\n把主存划分为若干区域，每个区域值分配给一个用户作业使用并限定只能在自己的区域中运行；基于分区方式的不同可划分为：固定分区、可变分区、可重定位分区 使用分区表、标定每个区的区号、大小、起始地址和是否分配标志。\n由于分区大小固定，分配后剩余的空间很容易被浪费掉! 根据程序的大小，使用不同的算法重新分配到各个分区中 依然有空间的浪费，但相比固定分区要好很多\n通过移动内存中作业的位置，然后把原来多个分散的空闲小分区拼接成一个大分区。此时若不对程序和数据的地址加以修改（变换），则程序必将无法执行。为此，在每次“紧凑”后，都必须对移动了的程序或数据进行重定位。** 但由于重定位会增加系统开销，必须选择合适的时机进行，通常有一下两种：\n分区回收时执行；\n找不到足够大空间时执行：\n分页存储管理\n为了解决分区存储管理中会产生的大量碎片，分页存储的思想被提出了。\n计提思路是：把主存存储空间划分为大小一定的块（称为物理块、或页框），把要执行的作业也按照同样的尺寸划分，如此作业便可以零散的放于主存的不连续的页框中，但需要增加页表(页号和页框的映射关系)去寻址。\n如上图所示，作业的各个页面与页框的对应，就是通过页表来实现。 把作业的地址空间划分成若干个大小相等的区域，称这样的每个区为页面或者简称页。\n相应地，也需将主存空间划分为若干个大小相等的物理块，并使块与页的大小相同，这样，在将用户程序装入内存时，刚好一块中放页。\n页的大小通常在 512B～4KB范围。\n简称页表，其中列出了作业的逻辑地址与其在主存中 的物理地址间的对应关系。\n一个页表中包含若干个表目，表目中的最基本内容是该页对应的物理块号。 假设每个页和物理块的大小均为1024B，逻辑地址为2100(十进制)，计算其物理地址？解：\n页号：页号 = 逻辑地址 / 页大小，即：2100 / 1024 = 2 物理块偏移量 = 页偏移量 = 逻辑地址 % 页大小，即：2100 % 1024 = 52 物理块地址 = 物理块号(根据页表和所得页号查找) * 页大小 + 物理块偏移量，即：8 * 1024 + 52 = 8244 分段存储管理\n分段式存储管理的作业空间是以段为单位的，每个段将占据一个连续的存储区域，但各段之间不必连续。\n这样，一个作业的各个分段在主存的情况用一个段表来记录，它指出了主存中各个分段的起始地址和长度。\n相对于分页存储来说，分段可以根据程序的实际情况，将程序内联系比较紧密的部分划分到一个段内，保护程序内部的逻辑完整性。\n段表由段号、段长、段始址组成。其中段长起到了限长的作用，逻辑地址到物理地址的换算和分页类似\n段页式存储管理\n段页式存储管理兼顾了段式在逻辑上的清晰和页式在管理上方便的特点。\n每一个装入内存的作业建立一张段表（基于作业），对每一段建立一张页表（系统决定页大小）\n逻辑地址到物理地址的计算：\n访问段表获取段表始址 根据段表始址计算段表分页的页号，从而得到页表始址 根据得到的页表地址得到具体的物理 4.磁盘存储器 磁盘存储器一般由组合臂、主轴、读写头、盘面组成，盘面又分磁道，磁道分有扇区，扇区用来存储数据。所以磁盘存储器的存储容量 = 磁盘面数 x 每面的磁道数 x 每道扇区 x 每个扇区存储字节数，硬盘的存取时间 = 寻道时间 + 等待时间 +读/写时间。\n为了加深对硬盘存取时间理解，看下面一道例题：\n在磁盘上存储数据的排列方式会影响 I/O 服务的总时间。假设每磁道划 分成 10 个物理块，每块存放 1 个逻辑记录。逻辑记录 RI.R2， \u0026hellip;， RI0存放在同一个磁道上， 记录的安排顺序如下表所示;\n假定磁盘的旋转速度为 30ms/周，磁头当前处在 R1 的开始处。若系统顺 序处理这些记录，使用单缓冲区，每个记录处理时间为 6ms，则处理这 10 个记录的最长时间为 （） ;若对信息存储进行优化分布后，处理 10 个 记录的最少时间为（）\n解：\n磁头初始位置如图所示，读取一条指令的时间 = 30ms / 10 = 3ms，处理一条指令耗时6ms，在处理完R1后，磁头位置如图所示(R1处理完)，此时耗时3ms(读) + 6ms(执行) = 9ms；\n如果开始处理R2，磁头需要从当前位置（R1处理完）空转到R2执行开始处，耗时8 x 3ms = 24ms，因此处理完R1并回到R2的开始位置总耗时 24ms + 9ms = 33ms；\n从R1\u0026hellip;R9的耗时 = 33ms x 9 = 297ms，R10读取和执行也需要9ms，因此总耗时 = 297ms + 9ms = 306ms\n假设从新排了顺序使得每次处理完磁头所在位置刚好是下一个要执行的指令，由第一问可知，一条指令完整的执行时间为9ms，10条则为90ms\n","pubDate":"2022-05-12","title":"操作系统基础-存储管理"},{"link":"http://xxx.xxx/posts/os/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80-%E8%BF%9B%E7%A8%8B/","plain":"进程 操作系统：系统进行资源分配和调度的基本单位，也是最小单位。 用户角度：程序一次动态执行过程 组成 进程通常有程序、数据集合、进程控制块PCB组成。PCB是一种数据结构，是进程存在的唯一标识。\nPCB有三种组织方式：\n线性表方式：每次查询全表扫描 索引表方式：按照进程的状态分别建立就绪索引表、阻塞索引表等 链接表方式：按照进程的状态将进程的PCB组成队列，从而形成就绪队列、阻塞队列、运行队列 三态模型 ","pubDate":"2022-05-12","title":"操作系统基础-进程"},{"link":"http://xxx.xxx/posts/java/javax.validation/","plain":"javax.validation使用说明 使用javax.validation的一系列注解可以帮我们完成参数校验,免去繁琐的串行校验。\n引入maven依赖 1 2 3 4 5 6 7 8 9 10 11 \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;javax.validation\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;validation-api\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;1.1.0.Final\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!-- 实现以及拓展 --\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.hibernate\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;hibernate-validator\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;5.4.1.Final\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; 注解说明 注解 验证类型 说明 @AssertFalse Boolean, boolean 验证是否为false @AssertTrue Boolean, boolean 验证是否为false @NotNull Object 是否不为null @Null Object 是否为null @Min BIgDecimal, BigInteger, Byte, short, int, long等Number或CharSequence子类型 是否小于等于指定值 @Max 同@Min 是否大于等于指定值 @DecimalMin 同@Min 验证注解的元素值大于等于@ DecimalMin指定的value值 @DecimalMax 同@Min 验证注解的元素值小于等于@ DecimalMin指定的value值 @Digits(integer=整数位数, fraction=小数位数) 同@Min 验证注解的元素值的整数位数和小数位数上限 @Size(min=下限, max=上限) 字符串、Collection、Map、数组等 验证注解的元素值的在min和max（包含）指定区间之内，如字符长度、集合大小 @Past java.util.Date,java.util.Calendar;Joda Time类库的日期类型 验证注解的元素值（日期类型）比当前时间早 @Future 同@Past 验证注解的元素值（日期类型）比当前时间晚 @NotBlank CharSequence子类型 去除首位空格后长度不为0 @Length(min=下限, max=上限) CharSequence子类型 验证注解的元素值长度在min和max区间内 @NotEmpty CharSequence子类型、Collection、Map、数组 验证注解的元素值不为null且不为空 @Range(min=最小值, max=最大值) BigDecimal,BigInteger,CharSequence, byte, short, int, long等原子类型和包装类型 验证注解的元素值在最小值和最大值之间 @Email(regexp=正则表达式,flag=标志的模式) CharSequence子类型 验证注解的元素值是Email，也可以通过regexp和flag指定自定义的email格式 @Valid 任何非原子类型 指定递归验证关联的对象如用户对象中有个地址对象属性，如果想在验证用户对象时一起验证地址对象的话，在地址对象上加@Valid注解即可级联验证 ","pubDate":"2022-03-11","title":"javax.validation"},{"link":"http://xxx.xxx/posts/arithmetic/pascals-triangle/","plain":"杨辉三角 杨辉三角的性质：每个数等于它上方两数之和\n思路 根据上述杨辉三角性质，新的行，是根据上一行的值两两相加得来, 为了便于取值我们在计算下一行时可以为上一行补0，如下\n1 0 1 0 1 1 0 1 1 0 1 2 1 --\u0026gt; 0 1 2 1 0 1 3 3 1 0 1 3 3 1 0 1 4 6 4 1 0 1 4 6 4 1 0 例如当我们计算第三行时，可以给第二行补0，于是就有\n1 0 1 1 0 1 2 1 于是，代码逻辑就比较简单了:\n1 2 3 4 5 6 def triangles(): N = [1] while True: yield N tmp = [0] + N + [0] N = [tmp[i] + tmp[i+1] for i in range(0, len(tmp)-1)] 进阶: 此时已经搞清楚了计算思路，可以再搞搞上层建筑(优化)了^_^ 借助zip函数，可以很轻易的将相加的两个数放到一起，比如：\nL = [1, 1] # 左补0 LL = [0, 1, 1] # 右补0 RL = [1, 1, 0] zip(LL, Rl) -\u0026gt; [(0, 1), (1, 1), (1, 0)] # 对比左右补0 [0, 1, 1, 0] 代码可优化为:\n1 2 3 4 5 def triangles(): N = [1] while True: yield N N = [sum(i) for i in zip([0] + N, N + [0])] ","pubDate":"2018-11-28","title":"杨辉三角"},{"link":"http://xxx.xxx/posts/arithmetic/hanoi-tower/","plain":"递归思路决绝汉诺塔问题 汉诺塔：汉诺塔（又称河内塔）问题是源于印度一个古老传说的益智玩具。\n大梵天创造世界的时候做了三根金刚石柱子，在一根柱子上从下往上按照大小顺序摞着64片黄金圆盘。 大梵天命令婆罗门把圆盘从下面开始按大小顺序重新摆放在另一根柱子上。并且规定，在小圆盘上不能放大圆盘，在三根柱子之间一次只能移动一个圆盘\n思路 假设需要将A上的圆盘移动到C\n从圆盘较少然后依次增加找规律：数字代表圆盘大小和位置 当A只有一个圆盘时(1)，不用想直接A -\u0026gt; C 当A只有两个圆盘时(1/2)，要借助B完成。先 A -\u0026gt; B,然后就可以把最大一个从A -\u0026gt; C,先不着急B -\u0026gt; C. 分析一下此时C有最大的圆盘，那么任何圆盘都可以直接放到C上，此时C可以认为是空的。B上有一个圆盘，如果把B看做A，A看做B，就回到了\u0026lt;1\u0026gt;那种情况 当A只有三个圆盘时(1/2/3)，先不要着急移动。想要把A上的圆盘全部移动到C上，必定需要把A最底部的最大的圆盘移动到C.将1/2两个圆盘看做一个整体，则可以直接按照\u0026lt;2\u0026gt;操作了，超级伪代码如下： A(1/2) -\u0026gt; B A(3) -\u0026gt; C B(1/2) -\u0026gt; C 执行\u0026lt;2\u0026gt;的步骤 代码实现 n代表圆盘的数量，a,b,c代表柱子\n1 2 3 4 5 6 7 8 9 10 11 12 def move(n, a, b, c): if n == 1: print(\u0026#34;从 %s 移动一个圆盘到 %s\u0026#34; % (a, c)) else: # 将圆盘数-1(除去最大的圆盘)借助c移动到b move(n-1, a, c, b) # 将a上最大圆盘一定到c print(\u0026#34;从 %s 移动一个圆盘到 %s\u0026#34; % (a, c)) # 将a看做b，b看做a，重复执行 move(n-1, b, a, c) # 方法调用 move(3, \u0026#34;A\u0026#34;, \u0026#34;B\u0026#34;, \u0026#34;c\u0026#34;) ","pubDate":"2018-11-24","title":"汉诺塔"},{"link":"http://xxx.xxx/posts/php/install/","plain":"编译安装PHP7.4 操作环境：\nphp: https://www.php.net/distributions/php-7.4.21.tar.gz\nos: CentOS Linux release 7.9.2009 (Core)\n1. 解压安装文件 1 2 3 4 5 6 # 一般我会把资源文件放到/usr/local/src下 $ cd /usr/local/src # 没有wget可以yum安装下，或直接用curl也可以 $ wget https://www.php.net/distributions/php-7.4.21.tar.gz $ tar -zxvf php-7.4.21.tar.gz $ cd php-7.4.21 2. 安装依赖 1 2 # 以下依赖是下面configure必须使用到的，如果有其他额外配置可自行安装 $ yum install -y gcc gcc-c++ make zlib zlib-devel pcre pcre-devel libxml2 libxml2-devel krb5 krb5-devel openssl openssl-devel sqlite-devel m4 autoconf epel-release oniguruma oniguruma-devel 3. 安装libpcre2-8 1 2 3 4 5 6 7 8 9 10 $ cd /usr/local/src $ wget https://ftp.pcre.org/pub/pcre/pcre2-10.35.tar.gz $ tar -zxvf pcre2-10.35.tar.gz $./configure --prefix=/usr/local/pcre2 \\ --enable-pcre2-16 \\ --enable-pcre2-32 \\ --enable-jit \\ --enable-jit-sealloc $ make \u0026amp;\u0026amp; make install $ export PKG_CONFIG_PATH=/usr/local/pcre2/lib/pkgconfig/ 4.编译安装php 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 $ cd /usr/local/src/php-7.4.21 $ ./configure \\ --prefix=/usr/local/php74 \\ --with-config-file-path=/usr/local/etc \\ --enable-fpm \\ --with-fpm-user=www \\ --with-fpm-group=www \\ --with-openssl \\ --with-kerberos \\ --with-system-ciphers \\ --with-external-pcre \\ --with-pcre-jit \\ --with-zlib \\ --with-pdo-mysql \\ --enable-bcmath \\ --enable-mbstring # 如果没有出现错误就继续，反正我是没有😄 $ make $ make install 5. 其他 配置PATH 自启动 php.ini 以及 php-fpm.conf修改 ","pubDate":"2018-06-13","title":"编译安装PHP7.4"}];
    var search_theEnd = "到底了";
    var search_nothing = "什么也没找到";
    var search_found = "找到";
    var search_result = "条结果";
    var search_results = "条结果";
</script>





    </body>
</html>

